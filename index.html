<!doctype html>
<html>
<head>
	<title>眼球逃生历险记 - Synesthesia (in space)</title>
	<link rel="shortcut icon" href="/favicon.ico?v=1">
	<meta charset="utf-8">
	<!-- for Google -->
	<meta name="description" content="Find your way through space puzzles, and save your love!" />
	<meta name="application-name" content="Synesthesia in Space" />
	<!-- for Facebook   -->
	<meta property="og:title" content="Synesthesia in Space" />
	<meta property="og:image" content="featured.png" />
	<meta property="og:url" content="http://gityx.com/" />
	<meta property="og:description" content="Find your way through space puzzles, and save your love!" />
	<!-- for Twitter   -->
	<meta name="twitter:title" content="Synesthesia in Space" />
	<meta name="twitter:description" content="Find your way through space puzzles, and save your love!" />
	<meta name="twitter:image" content="featured.png" />
	<style type="text/css">
	/* Font Designed by FutureMillennium */
	/* FontFace Generated by FontPro */

	@font-face {
	  font-family: 'fp-9626';
	  src: url('font/pixel millennium.eot');
	  src: url('font/pixel millennium.eot?#iefix') format('embedded-opentype'),
	       url('font/pixel millennium.woff') format('woff'),
	       url('font/pixel millennium.ttf') format('truetype'),
	       url('font/pixel millennium.svg#fp-9626') format('svg');
	}
	body {
	  font-family: 'fp-9626',sans-serif;
	  margin: 0; padding: 0; background: #000;
	}
	#container {
		position: absolute; width: 100%; height: 100%;
	}
	#canvas {
		display: block;
	}
	#loading {
		position: absolute;
		top: 50%;
		bottom: 50%;
		text-align: center;
		width: 100%;
		margin-top: -30px;
		font-size: 27px;
		color: #FFF; 
	}
	#fps{
		position: absolute;
		bottom: 0;
	}
	</style>
</head>
<body>
	<div id="container"><canvas id="canvas"></canvas></div>
	<div id="loading" style="">0%</div>
	<!-- <div id="fps"></div> -->
	
<script>

function clone(obj) {
	// Handle the 3 simple types, and null or undefined
	if (null == obj || "object" != typeof obj) return obj;

	// Handle Date
	if (obj instanceof Date) {
		var copy = new Date();
		copy.setTime(obj.getTime());
		return copy;
	}

	// Handle Array
	if (obj instanceof Array) {
		var copy = [];
		for (var i = 0, len = obj.length; i < len; i++) {
			copy[i] = clone(obj[i]);
		}
		return copy;
	}

	// Handle Object
	if (obj instanceof Object) {
		var copy = {};
		for (var attr in obj) {
			if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);
		}
		return copy;
	}

	throw new Error("Unable to copy obj! Its type isn't supported.");
}

function extend(){
	var obj = clone(arguments[0]);
    for(var i=1; i<arguments.length; i++)
        for(var key in arguments[i])
            if(arguments[i].hasOwnProperty(key))
                obj[key] = arguments[i][key];
    return obj;
}
</script>

	<script type="text/javascript" src="tileindex.js"></script>
	<script type="text/javascript" src="levels.js"></script>
	<script type="text/javascript" src="animations.js"></script>
	<script>

var canvas = document.getElementById("canvas"),
	container = document.getElementById("container"),
	ctx = canvas.getContext("2d"),

	width = 1000,
	height = 500,

	keys = [],
	friction = 0.8,
	gravity = 0.2/50,
	tiles = [],
	entities = [],
	hasLens = [],
	tileWidth = 1,
	tileHeight = 1,
	level,
	player = {
		x : 0,
		y : 0,
		width : 1.5,
		height : 2.5,
		maxSpeed : 0.12,
		jumpSpeed : 0.19,
		accelSpeed : 0.04,
		velX : 0,
		velY : 0,
		jumping : false,
		grounded : true,
		dir: "right",
		alreadyPushedInFrame: false,
		timeNotJumping: 0
	},
	playerCleanAnim,
	deathTimeoutID = null,
	light = 0,
	fps = document.getElementById("fps"),
	fpsFrames = 0,
	fpsLastTime = (new Date()).getTime(),
	// colors = ["#c5c5c5", "#47a5ee", "#1de9e2", "#d8749c", "#676767"],
	colors = ["#9c9c9c", "#47a5ee", "#5da86b", "#d8749c", "#676767", "#fff"],
	colorsName = ["white", "blue", "green", "red", "grey", "transparent"],
	scale = 50,
	lastKeyEventTime = gameStartTime = frameTime = lastFrameTime = (new Date()).getTime(),
	timeDiff, timeDiffRelFPS,
	currentLevel = 0, tookKey = false,
	paused = true,
	specialPause = "",
	storyMode = true,storyFrame = 0, numStoryFrames = 5,
	gameEndMode = false,
	blockControls = false,
	pausedTime = (new Date()).getTime(),
	scrollerOffsetX = 0, scrollerOffsetY = 0,
	levelSizeX = 0, levelSizeY = 0,
	fading, faderCalledCallback, startFadeTime, faderCallback, fadeColor = "#000", fadeTimeLength = 1000,
	overlayMessage, overlayMessageAppearTime = 6000, overlayMessageFadeTime = 1000, overlayMessageTimeStart,
	audio = {},
	images = {};

canvas.width = width;
canvas.height = height;

(function() {
	var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
	window.requestAnimationFrame = requestAnimationFrame;
})();

function launchFullscreen(element) {
  if(element.requestFullscreen) {
    element.requestFullscreen();
  } else if(element.mozRequestFullScreen) {
    element.mozRequestFullScreen();
  } else if(element.webkitRequestFullscreen) {
    element.webkitRequestFullscreen();
  } else if(element.msRequestFullscreen) {
    element.msRequestFullscreen();
  }
}

function update(){
	if (fps) calcFps();

	frameTime = (new Date()).getTime();
	timeDiff = frameTime - lastFrameTime;
	timeDiffRelFPS = 60 / (1000 / timeDiff);
	
	checkKeys();

	if (!paused) {
		gameStartTime += pausedTime;
		pausedTime = 0;

		playerUpdate();
		entitiesUpdate();
		tilesUpdate();
	} else {
		pausedTime += timeDiff;
	}
	
	drawFrame();

	lastFrameTime = frameTime;

	// run through the loop again
	requestAnimationFrame(update);

	if (lastFrameTime - lastKeyEventTime > 1000 * 60 * 5) location.reload();
}

function entitiesUpdate () {
	for (var i = 0; i < entities.length; i++) {
		entity = entities[i];
		entity.alreadyPushedInFrame = false;
		switch (entity.type){
			case "turret":

				if (Math.pow(player.x - entity.x, 2) + Math.pow(player.y - entity.y, 2) < entity.radius)
					{
						if (entity.isIdle) {setAnimation(entity, colorsName[entity.c]+"_gun_start_"+entity.dir); entity.sinceShot = 0; }
						entity.isIdle = false;
						if (!entity.sinceShot) entity.sinceShot = 0;
						if (!entity.currentShot) entity.currentShot = 0;
						entity.sinceShot+=timeDiff;
						if (entity.shots[entity.currentShot] < entity.sinceShot) {
							
							if (entity.c != light){
								setAnimation(entity, colorsName[entity.c]+"_gun_fire_"+entity.dir);
								playAudio('cannon');
								entities.push({
									type: 'bullet',
									x: entity.x+(entity.dir == "left"?-0.2:entity.width),
									y: entity.y+0.55,
									velX: entity.dir == "left"?-0.1:0.1,
									width: 0.6,
									height: 0.1,
									c: entity.c,
									enemy: true
								});
							}
							// entity.sinceShot -= entity.shots[entity.currentShot];
							entity.sinceShot = 0;
							entity.currentShot = (entity.currentShot + 1) % entity.shots.length;
						}
					} else {
						if (!entity.isIdle) setAnimation(entity, colorsName[entity.c]+"_gun_end_"+entity.dir);
						entity.isIdle = true;
					}
				break;
			case "bullet":
				entity.x += entity.velX * timeDiffRelFPS;
				if (entity.x+entity.width<0 || entity.x > width) entities.splice(i--, 1);
				break;
		}
		if (entity.type!="bullet") {
			entity.velX *= Math.pow(friction, timeDiffRelFPS);
			entity.velY += gravity * timeDiffRelFPS;

			if (entity.grounded) entity.velY *= entity.velY<0.1 ? 0 : -0.2;

			var cx = entity.velX * timeDiffRelFPS,
				cy = entity.velY * timeDiffRelFPS;
			entity.x += Math.abs(cx)<0.5?cx:cx/Math.abs(cx)*0.5;
			entity.y += Math.abs(cy)<0.5?cy:cy/Math.abs(cy)*0.5;
		}
	}
}

function tilesUpdate() {
	player.grounded = false;
	for (var i = 0; i < entities.length; i++) entities[i].grounded = false;
	for (var y = 0; y < tiles.length; y++) {
		for (var x = 0; x < tiles[y].length; x++) {

			tile = tiles[y][x];
			//player tile collision
			if (tile && tile.c!=light) {
				doCollisionObjectTile(player, tile);
				for (var i = 0; i < entities.length; i++)
					if (doCollisionObjectTile(entities[i], tile) && entities[i].type=="bullet") entities.splice(i--, 1);
			}

			if (tile && tile.roundTime) {
				
				phase = (Math.abs(((frameTime - gameStartTime) % tile.roundTime) / tile.roundTime * 2 - 1) - 0.5) * 2;
				if (phase<0) phase = -1 + Math.pow((-1 - phase),2);
				if (phase>0) phase =  1 - Math.pow(( 1 - phase),2);
				phase = 1 - (phase + 1) / 2;

				if (tile.fromY && tile.toY) {
					potentialY = tile.fromY * (1 - phase) + tile.toY * phase;
					changeY = (potentialY - tile.y) - tile.offsetY;
					tile.offsetY += changeY;
					if (player.grounded && player.standingOn == tile) player.y+=changeY;
					for (var i = 0; i < entities.length; i++)
						if (entities[i].grounded && entities[i].standingOn == tile) entities[i].y+=changeY;
				}

				if (tile.fromX && tile.toX) {
					potentialX = tile.fromX * (1 - phase) + tile.toX * phase;
					changeX = (potentialX - tile.x) - tile.offsetX;
					tile.offsetX += changeX;
					if (player.grounded && player.standingOn == tile && !player.alreadyPushedInFrame) { player.x+=changeX; player.alreadyPushedInFrame = true;};
					for (var i = 0; i < entities.length; i++)
						if (entities[i].grounded && entities[i].standingOn == tile && !entities[i].alreadyPushedInFrame) { entities[i].x+=changeX; entities[i].alreadyPushedInFrame = true; }
				}
			}
		}
	}
}

function canChangeFromLight() {
	for (var y = 0; y < tiles.length; y++) {
		for (var x = 0; x < tiles[y].length; x++) {
			tile = tiles[y][x];
			if (tile && tile.c==light) {
				var col = colCheck(player, {
					x : (tile.x+tile.offsetX)*tileWidth,
					y : (tile.y+tile.offsetY)*tileHeight,
					width : tileWidth,
					height: tileHeight
				}, true);
				if (col.dir && (col.oX>=col.oY && col.oY>0.5) || (col.oX<col.oY && col.oX>0.5)) return false;
			}
		}  
	}
	return true;
}

function doCollisionObjectTile(obj, tile)
{
	var dir = colCheck(obj, {
		x : (tile.x+tile.offsetX)*tileWidth,
		y : (tile.y+tile.offsetY)*tileHeight,
		width : tileWidth,
		height: tileHeight
	}).dir;

	if (dir === "l" || dir === "r") {
		obj.velX = 0;
		obj.jumping = false;
	} else if (dir === "b") {
		obj.standingOn = tile;
		if (!obj.grounded && obj == player && Math.abs(obj.velY>0.1) ) playAudio('land');
		if (!obj.grounded && obj == player && player.animation == playerAnimationName('jumping')) setPlayerAnimation('landing');
		if (tile.dangerousUp && obj == player) die();
		obj.grounded = true;
		obj.jumping = false;
	} else if (dir === "t") {
		if (tile.dangerousDown && obj == player) die();
		if (obj.velY < 0) obj.velY = 0;
	}
	return dir;
}

function playerUpdate() {
	player.alreadyPushedInFrame = false;

	if (player.grounded) player.timeNotJumping+=timeDiff;
	else player.timeNotJumping = 0;

	player.velX *= Math.pow(friction, timeDiffRelFPS);
	player.velY += gravity * timeDiffRelFPS;

	// if (player.grounded) player.velY *= player.velY<0.1 ? 0 : -0.2;
	if (player.grounded) player.velY = 0;

	// audio['step1'].loop = true;
	// audio['step2'].loop = true;
	if (player.grounded && Math.abs(player.velX)>0.05) 
		{
			if (player.animation != playerAnimationName('walking') && player.animation != playerAnimationName('walkingStart'))
				setPlayerAnimation('walkingStart', false, true);
			// audio['step1'].play();
			// audio['step2'].play();
			// audio['step2'].currentTime = 0.5;
		} else {
			if (player.animation == playerAnimationName('walking') || player.animation == playerAnimationName('walkingStart')) setPlayerAnimation('standing');
			// audio['step1'].pause();
			// audio['step2'].pause();
		}

	if (player.velX < 0) {player.dir = "left"; checkPlayerAnimation(); }
	if (player.velX > 0) {player.dir = "right"; checkPlayerAnimation(); }
	// setAnimation(player, playerCleanAnim);

	player.x += player.velX * timeDiffRelFPS;
	player.y += player.velY * timeDiffRelFPS;

	// colCheckPlayerTiles();
	colCheckPlayerEntity();

	if (player.y<0 || player.y > levelSizeY) die();
}

function checkPlayerAnimation()
{
	player.animation = playerAnimationName(playerCleanAnim);
}

function colCheckPlayerEntity() {
	for (var i = 0; i < entities.length; i++) {
		entity = entities[i];
		if (entity && entity.c!=light) {
			var dir = colCheck(player, entity, true).dir;

			if (dir) {

				if (entity.enemy)
					die();

				switch (entity.type){
					case "key":
						playAudio('keyGrab');
						tookKey = true;
						entities.splice(i--,1);
						break;
					case "door":
						if (tookKey && entity.doorType == 'exit')
							finishLevel(entity);
						break;
					case "lens":
						if (entity.lensColor) {
							hasLens.push(entity.lensColor);
							playAudio('keyGrab');
							// paused = true;
							overlayMessageTimeStart = frameTime;
							switch (entity.lensColor) {
								case colorRed: overlayMessage = "lens1"; break;
								case colorGreen: overlayMessage = "lens2"; break;
								case colorBlue: overlayMessage = "lens3"; break;
								default: overlayMessage = null; break;
							}
							entity.lensColor = 0;
							setAnimation(entity, "empty_lens")
						}
						// entities.splice(i--,1);
						break;
				}
			}
		}
	}
}

function finishLevel (door) {
	if (blockControls) return;
	blockControls = true;
	setAnimation(door, colorsName[entity.c]+'_door_open');
	setTimeout(function() { fader(function(){ blockControls = false; loadLevel(currentLevel+1); }, 1000, "#000"); }, 2000);
}

function die () {
	if (blockControls) return;
	blockControls = true;
	setPlayerAnimation('death');
	deathTimeoutID = setTimeout(deathTimeOutComplete, 4000);
}

function deathTimeOutComplete(){
	deathTimeoutID = null;
	fader(function(){ blockControls = false; loadLevel(currentLevel); }, 1000, "#200");
}

function speedDeath() {
	if (deathTimeoutID!==null) {
		clearTimeout(deathTimeoutID);
		deathTimeOutComplete();
	}
}

function fader(callback, speed, color, onlyOut)
{
	fading = true;
	faderCalledCallback = false;
	startFadeTime = (new Date()).getTime() + (onlyOut?-speed/2:0);
	faderCallback = callback;
	fadeColor = color;
	fadeTimeLength = speed;
}

function getLinearInterpolatedValueFromArray(f, a) {
	if (!a) return 0;
	if (!(a instanceof Array)) return a;
	var v = a[0].v, lf = a[0].f;
	for (var i = 1; i < a.length; i++) {
		if (a[i].f>=f) {
			return v + (a[i].v - v)*(f - lf)/(a[i].f - lf)
		} else {
			v = a[i].v;
			lf = a[i].f;
		}
	}
	return v;
}

function getMargins (obj) {
	if (!obj.animation) return {t:0, r:0, b:0, l:0};
	var anim = animations[obj.animation],
		f = obj.animationCurrentFrame;
	return {
		t:getLinearInterpolatedValueFromArray(f, anim.tMargin),
		r:getLinearInterpolatedValueFromArray(f, anim.rMargin), 
		b:getLinearInterpolatedValueFromArray(f, anim.bMargin), 
		l:getLinearInterpolatedValueFromArray(f, anim.lMargin)
	};
}

function colCheck(shapeA, shapeB, justToKnow) {
	marginA = getMargins(shapeA);
	marginB = getMargins(shapeB);
	// get the vectors to check against
	var vX = (shapeA.x + marginA.l + (shapeA.width - marginA.l - marginA.r) / 2) - (shapeB.x + marginB.l + (shapeB.width - marginB.l - marginB.r) / 2),
		vY = (shapeA.y + marginA.t + (shapeA.height - marginA.t - marginA.b) / 2) - (shapeB.y + marginB.t + (shapeB.height - marginB.t - marginB.b) / 2),
		// add the half widths and half heights of the objects
		hWidths = (shapeA.width + shapeB.width - marginA.l - marginA.r - marginB.l - marginB.r) / 2,
		hHeights = (shapeA.height + shapeB.height - marginA.t - marginA.b - marginB.t - marginB.b) / 2,
		colDir = null;
 
 	var oX = 0, oY = 0;
	// if the x and y vector are less than the half width or half height, they we must be inside the object, causing a collision
	if (Math.abs(vX) <= hWidths && Math.abs(vY) <= hHeights) {         // figures out on which side we are colliding (top, bottom, left, or right)
		oX = hWidths - Math.abs(vX);
		oY = hHeights - Math.abs(vY);
		if (oX >= oY) {
			if (vY > 0) {
				colDir = "t";
				if (!justToKnow) shapeA.y += oY;
			} else {
				colDir = "b";
				if (!justToKnow) shapeA.y -= oY;
			}
		} else {
			if (vX > 0) {
				colDir = "l";
				if (!justToKnow) shapeA.x += oX;
			} else {
				colDir = "r";
				if (!justToKnow) shapeA.x -= oX;
			}
		}
	}
	return {dir:colDir, oX: oX, oY: oY};
}

function checkKeys() {
	// check keys

	if (paused || blockControls) return;

	if (keys[38]) {
		// up arrow or space
		if(!player.jumping && player.grounded && player.timeNotJumping > 50){
			playAudio('jump');
			player.jumping = true;
			player.grounded = false;
			player.velY = -player.jumpSpeed;
			setPlayerAnimation('jumping');
		}
	}
	if (keys[39]) {
		// right arrow
		if (player.velX < player.maxSpeed) {
		   player.velX+=player.accelSpeed;
		}
	}
	if (keys[37]) {
		// left arrow                  
		if (player.velX > -player.maxSpeed) {
		   player.velX-=player.accelSpeed;
		}
	}
	// if (keys[75]) die();

	// if (keys[65]) {
	// 	toggleLight(3);
	// }
	// if (keys[83]) {
	// 	toggleLight(2);
	// }
	// if (keys[68]) {
	// 	toggleLight(1);
	// }
	// if (keys[87]) {
	// 	toggleLight(0);
	// }
}

function toggleLight (l) {
	if (hasLens.indexOf(l) == -1 && l!=0) return;
	if (light == l) {
		if (light != 0) toggleLight(0);
		return;
	}
	if (canChangeFromLight()) {
		light = l; playAudio("lensChange");
		fader(function(){  }, 500, "#FFF", true);
	}
}


function drawFrame() {
	ctx.clearRect(0,0,width,height);

	if (storyMode || gameEndMode) {
		ctx.fillStyle = "#000";
		ctx.fillRect(0,0,width,height);
		if (storyMode) {
			switch (storyFrame) {
				case 0:
				ctx.drawImage(images['frame1'], 0, 0, 1920, 1080, width/2-1920/56*scale/2,height/2-1080/56*scale/2, 1920/56*scale, 1080/56*scale); break;
				case 1:
				ctx.drawImage(images['frame2'], 0, 0, 1920, 1080, width/2-1920/56*scale/2,height/2-1080/56*scale/2, 1920/56*scale, 1080/56*scale); break;
				case 2:
				ctx.drawImage(images['frame3'], 0, 0, 1920, 1080, width/2-1920/56*scale/2,height/2-1080/56*scale/2, 1920/56*scale, 1080/56*scale); break;
				case 3:
				ctx.drawImage(images['frame4'], 0, 0, 1920, 1080, width/2-1920/56*scale/2,height/2-1080/56*scale/2, 1920/56*scale, 1080/56*scale); break;
				case 4:
				ctx.drawImage(images['game_start'], 0, 0, 1920, 1080, width/2-1920/56*scale/2,height/2-1080/56*scale/2, 1920/56*scale, 1080/56*scale); break;
			}
		} else if (gameEndMode) {
			ctx.drawImage(images['end_game'], 0, 0, 1920, 1080, width/2-1920/56*scale/2,height/2-1080/56*scale/2, 1920/56*scale, 1080/56*scale);
		}
		return;
	}

	ctx.fillStyle = "#000";//colors[light];
	ctx.fillRect(0,0,width,height);

	ctx.fillStyle = colors[light];
	ctx.fillRect(
		(0.5 - scrollerOffsetX)*tileWidth*scale,
		(0.5 - scrollerOffsetY)*tileHeight*scale,
		(tiles[0].length-1)*tileWidth*scale,
		(tiles.length-1)*tileHeight*scale);

	var bg = levels[currentLevel].background;
	if (bg) ctx.drawImage(images[bg], 0, 0, 56*levelSizeX, 56*levelSizeY, -scrollerOffsetX*tileWidth*scale,-scrollerOffsetY*tileHeight*scale, levelSizeX*scale, levelSizeY*scale);

	if (levelSizeX < width / scale) scrollerOffsetX = (scrollerOffsetX + levelSizeX / 2 - width / 2 / scale) / 2;
	else {
		var leftmost = ( player.x + 2*player.width / 5 - 2 * width / 5 / scale ); // leftmost
		var rightmost = ( player.x + 3*player.width / 5 - 3 * width / 5 / scale ); // rightmost
		rightmost = Math.min(rightmost, levelSizeX - width / scale);
		leftmost = Math.max(leftmost, 0);
		if (scrollerOffsetX < rightmost) scrollerOffsetX = (scrollerOffsetX + rightmost) / 2;
		else if (scrollerOffsetX > leftmost) scrollerOffsetX = (scrollerOffsetX + leftmost) / 2;
	}

	if (levelSizeY < height / scale) scrollerOffsetY = (scrollerOffsetY + levelSizeY / 2 - height / 2 / scale) / 2;
	else {
		var topmost = ( player.y + 2*player.height / 5 - 2 * height / 5 / scale ); // topmost
		var bottommost = ( player.y + 3*player.height / 5 - 3 * height / 5 / scale ); // bottommost
		bottommost = Math.min(bottommost, levelSizeY - height / scale);
		topmost = Math.max(topmost, 0);
		if (scrollerOffsetY < bottommost) scrollerOffsetY = (scrollerOffsetY + bottommost) / 2;
		else if (scrollerOffsetY > topmost) scrollerOffsetY = (scrollerOffsetY + topmost) / 2;
	}

	// draw tiles
	for (var y = 0; y < tiles.length; y++) {
		for (var x = 0; x < tiles[y].length; x++) {
			if (tiles[y][x]) {
				tile = tiles[y][x];
				if (tile.i) {
					ctx.drawImage(images[tile.i], tile.u * 56, tile.v * 56, 56, 56, (x+tile.offsetX - scrollerOffsetX)*tileWidth*scale, (y+tile.offsetY - scrollerOffsetY)*tileHeight*scale, tileWidth*scale+1, tileHeight*scale+1);
				} else {
					ctx.fillStyle = colors[tile.c];
					ctx.fillRect((x+tile.offsetX - scrollerOffsetX)*tileWidth*scale, (y+tile.offsetY - scrollerOffsetY)*tileHeight*scale, tileWidth*scale, tileHeight*scale);
				}
			}
		}
	}

	// draw entities
	for (var i = 0; i < entities.length; i++) {
		entity = entities[i];
		drawObject(entity);
	}

	drawObject(player);

	// pause
	if (paused) {
		ctx.globalAlpha = 0.75;
		ctx.fillStyle = "#000";
		ctx.fillRect(0, 0, width, height);
		ctx.globalAlpha = 1;
		ctx.drawImage(images[specialPause?specialPause:'pause'], 0, 0, 1920, 1080, width/2-1920/56*scale/2,height/2-1080/56*scale/2, 1920/56*scale, 1080/56*scale);
	}

	//overlay
	if (overlayMessage) {
		var timeSinceOverlay = frameTime - overlayMessageTimeStart;
		if (timeSinceOverlay > overlayMessageAppearTime) {
			overlayMessage = null;
		} else {
			// if (timeSinceOverlay < overlayMessageAppearTime - )
				// ctx.globalAlpha = 1;
			// else
			ctx.globalAlpha = Math.max(0, Math.min(1, (overlayMessageAppearTime - timeSinceOverlay) / overlayMessageFadeTime));
			ctx.drawImage(images[overlayMessage], 0, 0, 1920, 1080, width/2-1920/56*scale/2,height/2-1080/56*scale/2, 1920/56*scale, 1080/56*scale);
			ctx.globalAlpha = 1;
		}
	}

	if (fading) {
		var ft = (new Date()).getTime() - startFadeTime;
		ctx.globalAlpha = Math.max(0, 1 - Math.abs(ft - fadeTimeLength / 2) * 2 / fadeTimeLength);
		ctx.fillStyle = fadeColor;
		ctx.fillRect(0,0,width,height);
		ctx.globalAlpha = 1;
		if (!faderCalledCallback && ft > fadeTimeLength / 2) {
			faderCallback();
			faderCalledCallback = true;
		}
		if (ft > fadeTimeLength) fading = false;
	}
}

function playerAnimationName (anim) {
	return (hasLens.length==0?"before":colorsName[light])+"_"+anim+"_"+player.dir;
}

function setPlayerAnimation(anim, restart) {
	if (blockControls && playerCleanAnim=="death") return;
	playerCleanAnim = anim;
	setAnimation(player, playerAnimationName(anim), restart);
}

function setAnimation(obj, anim, restart, setwidth) {
	if (restart===false && obj.animation==anim) return;

	nanim = animations[anim];
	panim = animations[obj.animation];
	if (!panim) { pxCenter = 0.5; pyCenter = 0.5; } else {
		pxCenter = panim.xCenter?panim.xCenter:0.5;
		pyCenter = panim.yCenter?panim.yCenter:1;
	}
	nyCenter = nanim.yCenter?nanim.yCenter:1;
	nxCenter = nanim.xCenter?nanim.xCenter:0.5;

	var nw = animations[anim].w/56*(animations[anim].scale?animations[anim].scale:1),
		nh = animations[anim].h/56*(animations[anim].scale?animations[anim].scale:1);

	nw = Math.round(nw*10)/10;
	nh = Math.round(nh*10)/10;

	obj.x+=((obj.width?obj.width:0)*pxCenter-nw*nxCenter);
	obj.y+=((obj.height?obj.height:0)*pyCenter-nh*nyCenter);
	obj.width = nw;
	obj.height = nh;

	obj.animation = anim;
	obj.animationCurrentFrame = 0;
	obj.animationStartTime = (new Date()).getTime();
}

function drawObject(obj) {
	if (obj.animation) {

		anim = animations[obj.animation];

		var time = (new Date()).getTime() - obj.animationStartTime;
		var oacf = obj.animationCurrentFrame;
		obj.animationCurrentFrame = Math.floor(time / anim.time);
		
		switch (anim.loop)
		{
			case 'loop':
				obj.animationCurrentFrame %= anim.length;
				break;
			case 'pingpong':
				obj.animationCurrentFrame %= anim.length * 2;
				if (obj.animationCurrentFrame > anim.length - 1) obj.animationCurrentFrame = anim.length * 2 - obj.animationCurrentFrame - 1;
				break;
			case 'stick':
				obj.animationCurrentFrame = Math.min(obj.animationCurrentFrame, anim.length - 1);
				break;
			case 'stickFirst':
				if (obj.animationCurrentFrame > anim.length - 1) obj.animationCurrentFrame = 0;
				break;
			case 'switch':
				if (obj.animationCurrentFrame > anim.length - 1) {
					if (obj == player) {
						setPlayerAnimation(anim.switchTo);
						anim = animations[player.animation];
					} else {
						setAnimation(obj, anim.switchTo);
						anim = animations[anim.switchTo];
					}
				}
				break;
		}

		if (oacf!=obj.animationCurrentFrame) {
			if (anim.sounds)
				for (var i = 0; i < anim.sounds.length; i++) {
					if (anim.sounds[i].f == obj.animationCurrentFrame) playAudio(anim.sounds[i].k, false);
				};
		}

		ctx.drawImage(images[anim.image], anim.sx + anim.ox * obj.animationCurrentFrame, anim.sy + anim.oy * obj.animationCurrentFrame, anim.w, anim.h, (obj.x - scrollerOffsetX)*scale, (obj.y - scrollerOffsetY)*scale, obj.width*scale, obj.height*scale);

	} else {
		ctx.fillStyle = colors[obj.c];
		ctx.fillRect((obj.x - scrollerOffsetX)*scale, (obj.y - scrollerOffsetY)*scale, obj.width*scale, obj.height*scale);
	}
}

function calcFps() {
	if (!fps) return;
	fpsFrames++;
	var fpsCurrentTime = (new Date()).getTime();
	var fpsTimeDiff = fpsCurrentTime - fpsLastTime;
	if (fpsTimeDiff > 500) {
		fps.innerHTML = Math.floor(fpsFrames / fpsTimeDiff * 1000) + " fps";
		fpsFrames = 0;
		fpsLastTime = fpsCurrentTime;
	}
}


function loadLevel(l) {

	var previousMusic = "";
	if (level) previousMusic = level.music;

	tiles = [];
	if (l==levels.length) { gameEndMode = true; pause = true; return; }
	// l = l % levels.length;
	currentLevel = l;
	level = levels[l];
	light = 0;
	tookKey = false;
	gameStartTime = lastFrameTime = (new Date()).getTime();
	if (level.hasLens) hasLens = clone(level.hasLens);
	else hasLens = [];

	if (!level.music) level.music = 'mainLoop';
	if (previousMusic && previousMusic != level.music) audio[previousMusic].pause();
	playAudio(level.music, "yes");

	overlayMessage = null;
	
	//player setup
	player.dir = "right";
	player.x = level.playerPos.x;
	player.y = level.playerPos.y;
	player.velX = 0; player.velY = 0;
	setPlayerAnimation('standing');

	//tiles setup
	ltiles = level.tiles;
	levelSizeY = ltiles.length;
	levelSizeX = ltiles[0].length;
	for (var y = 0; y < ltiles.length; y++) {
		tiles[y] = [];
		for (var x = 0; x < ltiles[y].length; x++) {
			if (ltiles[y][x]) {
				tiles[y][x] = clone(tilesIndex[ltiles[y][x]]);
				if (tiles[y][x].c===undefined) tiles[y][x].c = 4;
				tiles[y][x].x = x; tiles[y][x].y = y;
				tiles[y][x].offsetX = 0; tiles[y][x].offsetY = 0;
				if (!tiles[y][x].fromX) tiles[y][x].fromX = x;
				if (!tiles[y][x].fromY) tiles[y][x].fromY = y;
				if (tiles[y][x].moveX) tiles[y][x].toX = tiles[y][x].fromX + tiles[y][x].moveX;
				if (tiles[y][x].moveY) tiles[y][x].toY = tiles[y][x].fromY + tiles[y][x].moveY;
				/*if (tile instanceof Object) {
					tiles[y][x] = clone(tile);
					tiles[y][x].y = y;
					tiles[y][x].x = x;
					tiles[y][x].offsetX = 0;
					tiles[y][x].offsetY = 0;
				} else {
					tiles[y][x] = {
						x: x,
						y: y,
						c: tile,
						offsetX: 0,
						offsetY: 0
					};
				}*/
			} else {
				tiles[y][x] = null;
			}
		}
	}

	//entities setups
	entities = clone(level.entities);
	for (var i = 0; i < entities.length; i++) {
		entity = entities[i];
		entity.velX = 0;
		entity.velY = 0;
		entity.jumping = false;
		entity.grounded = true;
		switch (entity.type) {
			case "turret":
				entity.isIdle = true;
				setAnimation(entity, colorsName[entity.c]+'_gun_idle_'+entity.dir);
				break;
			case "door":
				if (entity.doorType=="exit")
					setAnimation(entity, colorsName[entity.c]+"_door_idle");
				else if (entity.doorType=="entrance")
					setAnimation(entity, colorsName[entity.c]+"_door_close");
				break;
			case "key":
				setAnimation(entity, 'key');
				break;
			case "lens":
				setAnimation(entity, colorsName[entity.lensColor]+'_lens');
		}
	};
}

function resize () {

	width = canvas.width = container.clientWidth;
	height = canvas.height = container.clientHeight;

	var scaleByX = width / 35;
	var scaleByY = height / 19;

	scale = Math.min(scaleByY, scaleByX);
}

function playAudio (k, loop) {
	// if (!(audio instanceof Array) || !audio[k]) return;
	if (paused) return;
	if (loop) audio[k].loop = true;
	audio[k].currentTime = 0;
	audio[k].play();
}

window.addEventListener("load", function(){ resize(); document.getElementById("loading").style.display="none"; loadLevel(currentLevel); update(); });
window.addEventListener("resize", function(){ resize(); });

document.body.addEventListener("keydown", function(e) {

	keys[e.keyCode] = true;

	lastKeyEventTime = lastFrameTime;

});

document.body.addEventListener("keyup", function(e) {

	keys[e.keyCode] = false;
	if (deathTimeoutID!==null) {
		switch (e.keyCode) {
			case 32: case 75: case 65: case 83: case 68: case 87:
				speedDeath();
				return;
		}
	}
	if (e.keyCode == 32) { 
		if (storyMode) {
			storyNext();
		} else if (gameEndMode) {
			location.reload();
		} else {
			pressPause();
		}
	}

	if (paused || blockControls) return;

	switch (e.keyCode) {
		case 75: die(); break;
		case 65: toggleLight(3); break;
		case 83: toggleLight(2); break;
		case 68: toggleLight(1); break;
		case 87: toggleLight(0); break;
	}

	lastKeyEventTime = lastFrameTime;

});

function pointToOverlayPosition(p) {
	var ox = width/2-1920/56*scale/2,
		oy = height/2-1080/56*scale/2,
		sw = 1920/56*scale,
		sh = 1080/56*scale,
		x = p.x, y = p.y;

	x -= ox; y -= oy;
	x /= sw; y /= sh;
	x *= 1920; y *= 1080;

	return {x: x, y: y};
}

document.body.addEventListener("mousemove", function(e) {
	var m = pointToOverlayPosition({x: e.clientX, y: e.clientY});
	if (storyMode && storyFrame < 4) {
		canvas.style.cursor = (m.y > 837 && m.y < 933 && m.x > 785 && m.x < 1146)?'pointer':'default';
	} else if (storyMode) {
		canvas.style.cursor = (m.y > 596 && m.y < 692 && m.x > 785 && m.x < 1146)?'pointer':'default';
	} else if (paused) {
		canvas.style.cursor = (m.y > 516 && m.y < 612 && m.x > 785 && m.x < 1146)?'pointer':'default';
	} else {
		canvas.style.cursor = 'default';
	}
});

function pressPause(){
	paused = !paused;
	specialPause = "";
	var currentMusic = audio[level.music];
	if (currentMusic) paused?currentMusic.pause():currentMusic.play();
}



document.body.addEventListener("click", function(e) {
	var m = pointToOverlayPosition({x: e.clientX, y: e.clientY});
	if (storyMode && storyFrame < 4) {
		if (m.y > 837 && m.y < 933 && m.x > 785 && m.x < 1146) storyNext();
	} else if (storyMode) {
		if (m.y > 596 && m.y < 692 && m.x > 785 && m.x < 1146) storyNext();
	} else if (paused) {
		if (m.y > 516 && m.y < 612 && m.x > 785 && m.x < 1146) pressPause();
	}
});

function storyNext () {
	if (!storyMode) return;
	storyFrame++;
	if (storyFrame>=numStoryFrames) {
		storyMode = false;
		paused = false;
		loadLevel(currentLevel);
	}
}

var numImagesToLoad = numImagesLoaded = 0;
function loadImage(key, src){
	images[key] = new Image();
	images[key].src = 'images/'+src;
	images[key].onload = function(){ 
		numImagesLoaded++;
		document.getElementById("loading").innerHTML = Math.floor(numImagesLoaded / numImagesToLoad * 100) + "%";
		if ( numImagesLoaded==numImagesToLoad ) document.getElementById("loading").style.display="none"; }
	numImagesToLoad++;
}
function loadAudio(key, src){
	audio[key] = new Audio('audio/'+src);
	audio[key].preload = true;
}

// Player

loadImage('Jump_Red','Jump_Red.png');
loadImage('Jump_Blue','Jump_Blue.png');
loadImage('Jump_Green','Jump_Green.png');
loadImage('Jump_White','Jump_White.png');
loadImage('Jump_Before','Jump_Before.png');
loadImage('Run_Red','Run_Red.png');
loadImage('Run_Blue','Run_Blue.png');
loadImage('Run_Green','Run_Green.png');
loadImage('Run_White','Run_White.png');
loadImage('Run_Before','Run_Before.png');
loadImage('looks_Red','looks_Red.png');
loadImage('looks_Blue','looks_Blue.png');
loadImage('looks_Green','looks_Green.png');
loadImage('looks_White','looks_White.png');
loadImage('looks_Before','looks_Before.png');
loadImage('Death_Red','Death_Red.png');
loadImage('Death_Blue','Death_Blue.png');
loadImage('Death_Green','Death_Green.png');
loadImage('Death_White','Death_White.png');

// Entities
loadImage('gun','gun.png');
loadImage('key','key.png');
loadImage('doors','doors.png');
loadImage('lens','lenses_upgrades.png');

//Tiles
loadImage('tile_neutral','tile_neutral.png');
loadImage('tile_color','tile_color.png');
loadImage('spikes','spikes.png');

//Backgrounds
loadImage('backgroundlevel1','backgroundlevel1.png?v=2');
loadImage('backgroundlevel2','backgroundlevel2.png?v=2');
loadImage('backgroundlevel3','backgroundlevel3.png?v=2');
loadImage('backgroundlevel4','backgroundlevel4.png?v=2');
loadImage('backgroundlevel5','backgroundlevel5.png?v=2');
loadImage('backgroundlevel6','backgroundlevel6.png?v=2');
loadImage('backgroundlevel7','backgroundlevel7.png?v=2');
loadImage('backgroundlevel8','backgroundlevel8.png?v=2');
loadImage('backgroundlevel9','backgroundlevel9.png?v=2');
loadImage('backgroundlevel10','backgroundlevel10.png?v=2');

//Pause
loadImage('pause','pause.png');
loadImage('lens1','lens1.png?1');
loadImage('lens2','lens2.png?1');
loadImage('lens3','lens3.png?1');

//Story
loadImage('frame1','frame1.png');
loadImage('frame2','frame2.png');
loadImage('frame3','frame3.png');
loadImage('frame4','frame4.png');
loadImage('game_start','game_start.png');
loadImage('end_game','end_game.png');

loadAudio('mainLoop', 'MusicmainShort.mp3');
loadAudio('lensmusic', 'Music2.mp3');
// loadAudio('//', Audio('Music_RedLoop.mp3');
// loadAudio('//', Audio('Music_GreenLoop.mp3');
// loadAudio('//', Audio('Music_BlueLoop.mp3');
loadAudio('step1', 'Step1.mp3');
loadAudio('step2', 'Step2.mp3');
// loadAudio('levelFail', 'LevelFail.mp3');
// loadAudio('lensGrab', 'Lens_Grabs.mp3');
loadAudio('lensChange', 'Lens_Change.mp3');
loadAudio('land', 'Land.mp3');
loadAudio('keyGrab', 'Key_Grab.mp3');
loadAudio('jump', 'Jump.mp3');
// loadAudio('gameOver', 'GameOver.mp3');
loadAudio('doorShut', 'Door_Shut.mp3');
loadAudio('doorOpen', 'Door_Open.mp3');
loadAudio('cannon', 'Laser.mp3');
loadAudio('DeathSound', 'DeathSound.mp3');



//if(document.location.hostname!="synesthesia") {
//
//  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
//  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
//  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
//  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
//
//  ga('create', 'UA-47492796-1', 'synesthesiagame.com');
//  ga('send', 'pageview');
//
//} else {
//
//	console.log('skipped analytics tracking');
//
//}

</script>
</body>
</html>
<!--客服 开始-->
<script src="https://cdn.jsdelivr.net/gh/g8hh/g8hh.github.io/static/js/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/g8hh/g8hh.github.io/static/css/kf.css" type="text/css" media="screen" charset="utf-8">
<script src="https://cdn.jsdelivr.net/gh/g8hh/g8hh.github.io/static/js/kf.js"></script>
<!-- 客服 结束 -->
<!--站长统计-->
    <div style="display: none">
       <script type="text/javascript" src="https://v1.cnzz.com/z_stat.php?id=1280006740&web_id=1280006740"></script>
    </div>